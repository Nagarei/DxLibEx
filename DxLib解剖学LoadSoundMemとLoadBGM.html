<!DOCTYPE html>
<html lang="ja">
<head>
	<meta charset="utf-8">
	<title>DxLib解剖学LoadSoundMemとLoadBGM - DxLibEx Research Notes</title>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/4.1.0/sanitize.min.css">
	<link rel="stylesheet" href="style.css">
	<link rel="stylesheet" href="https://cdn.rawgit.com/yumetodo/syntaxhighlighterCustom/3.0.83.3/styles/shCore.css">
	<link rel="stylesheet" href="https://cdn.rawgit.com/yumetodo/syntaxhighlighterCustom/3.0.83.3/styles/shThemeMidnight_likeVS.css">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.3/themes/default/style.min.css">
	<script src="https://cdn.rawgit.com/yumetodo/syntaxhighlighterCustom/3.0.83.3/scripts/shCore.js"></script>
	<script src="https://cdn.rawgit.com/yumetodo/syntaxhighlighterCustom/3.0.83.3/scripts/shBrushPlain.js"></script>
	<script src="https://cdn.rawgit.com/yumetodo/syntaxhighlighterCustom/3.0.83.3/scripts/shBrushCpp_kai.js"></script>
	<script src="https://cdn.rawgit.com/yumetodo/syntaxhighlighterCustom/3.0.83.3/scripts/shBrushCppDxLib.js"></script>
	<script src="https://code.jquery.com/jquery-3.1.1.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.3/jstree.min.js"></script>
	<script>
		SyntaxHighlighter.all();
	</script>
</head>
<body>
	<h1>DxLib解剖学LoadSoundMemとLoadBGM</h1>
	<section>
		<h2>はじめに</h2>
		<p>
			DxLibにはLoadSoundMem　と LoadBGMという似た関数があります。これはどう違うのか。<br>
			DxLibExでラップする作業中に気になったので、調べてみました。
		</p>
	</section>
	<section>
		<h2>調査対象version</h2>
		<p><a href="http://dxlib.o.oo7.jp/dxdload.html">公式サイトから落とした</a><code>3.16f</code></p>
	</section>
	<section>
		<h2>2つの関数の呼び出しをたどる前におさえておきたいこと</h2>
		<section>
			<h3><code>LOADSOUND_GPARAM</code></h3>
			<p>まず引数経由でフラグを渡すための構造体定義が存在します。</p>
			<pre class="brush: cpp_dxlib; first-line: 74; highlight: [79];" title="DxSound.h">// ファイルからサウンドハンドルを作成する処理に必要なグローバルデータを纏めたもの
struct LOADSOUND_GPARAM
{
	int							NotInitSoundMemDelete ;					// InitSoundMem で削除しないかどうかのフラグ( TRUE:InitSoundMemでは削除しない  FALSE:InitSoundMemで削除する )
	int							Create3DSoundFlag ;						// 3Dサウンドを作成するかどうかのフラグ( TRUE:３Ｄサウンドを作成する  FALSE:３Ｄサウンドを作成しない )
	int							CreateSoundDataType ;					// 作成するサウンドデータのデータタイプ
	int							CreateSoundPitchRateEnable ;			// 作成するサウンドデータのピッチレートが有効かどうか
	float						CreateSoundPitchRate ;					// 作成するサウンドデータのピッチレート
	int							CreateSoundTimeStretchRateEnable ;		// 作成するサウンドデータのタイムストレッチレートが有効かどうか
	float						CreateSoundTimeStretchRate ;			// 作成するサウンドデータのタイムストレッチレート
	int							CreateSoundLoopStartTimePosition ;		// 作成するサウンドデータのループ範囲の先端( ミリ秒 )
	int							CreateSoundLoopStartSamplePosition ;	// 作成するサウンドデータのループ範囲の先端( サンプル )
	int							CreateSoundLoopEndTimePosition ;		// 作成するサウンドデータのループ範囲の終端( ミリ秒 )
	int							CreateSoundLoopEndSamplePosition ;		// 作成するサウンドデータのループ範囲の終端( サンプル )
	int							DisableReadSoundFunctionMask ;			// 使用しない読み込み処理のマスク
#ifndef DX_NON_OGGVORBIS
	int							OggVorbisBitDepth ;						// ＯｇｇＶｏｒｂｉｓ使用時のビット深度(1:8bit 2:16bit)
	int							OggVorbisFromTheoraFile ;				// Ogg Theora ファイル中の Vorbis データを参照するかどうかのフラグ( TRUE:Theora ファイル中の Vorbis データを参照する )
#endif
} ;
</pre>
		</section>
		<section>
			<h3><code>SOUNDSYSTEMDATA</code></h3>
			<p>DxLib内部でのフラフの保管につかうグローバル変数として</p>
			<pre class="brush: cpp_dxlib; first-line: 89;" title="DxSound.cpp">// サウンドシステムデータ
SOUNDSYSTEMDATA SoundSysData ;</pre>
			<p>があります。<code>SOUNDSYSTEMDATA</code>は</p>
			<pre class="brush: cpp_dxlib; first-line: 350; highlight: [396];" title="DxSound.h">// サウンドシステム用データ構造体
struct SOUNDSYSTEMDATA
{
	int							InitializeFlag ;				// 初期化フラグ

	DWORD						OutputChannels ;				// 出力チャンネル数
	DWORD						OutputSmaplesPerSec ;			// 出力サンプリングレート

	int							_3DSoundOneMetreEnable ;		// _3DSoundOneMetre が有効かどうか( TRUE:有効  FALSE:無効 )
	float						_3DSoundOneMetre ;				// ３Ｄサウンド処理用の１メートル
	_3DSOUNDINFO				ListenerInfo ;					// ３Ｄサウンドのリスナーの情報
	VECTOR						ListenerSideDirection ;			// ３Ｄサウンドのリスナーの横方向

	HANDLELIST					_3DSoundListFirst ;				// ３Ｄサウンドハンドルリストの先頭
	HANDLELIST					_3DSoundListLast ;				// ３Ｄサウンドハンドルリストの終端
	DX_CRITICAL_SECTION			_3DSoundListCriticalSection ;	// ３Ｄサウンドリストアクセス時用クリティカルセクション

	HANDLELIST					StreamSoundListFirst ;			// ストリームサウンドハンドルリストの先頭
	HANDLELIST					StreamSoundListLast ;			// ストリームサウンドハンドルリストの終端
	DX_CRITICAL_SECTION			StreamSoundListCriticalSection ;// ストリームサウンドハンドルリストアクセス時用クリティカルセクション

	HANDLELIST					SoftSoundPlayerListFirst ;		// ソフトウエアで扱う波形データのプレイヤーのハンドルリストの先頭
	HANDLELIST					SoftSoundPlayerListLast ;		// ソフトウエアで扱う波形データのプレイヤーのハンドルリストの終端

	HANDLELIST					PlayFinishDeleteSoundListFirst ; // 再生終了時に削除するサウンドハンドルリストの先頭
	HANDLELIST					PlayFinishDeleteSoundListLast ;	 // 再生終了時に削除するサウンドハンドルリストの終端

	HANDLELIST					Play3DSoundListFirst ;			// 再生している３Ｄサウンドリストの先頭
	HANDLELIST					Play3DSoundListLast ;			// 再生している３Ｄサウンドリストの終端
	DX_CRITICAL_SECTION			Play3DSoundListCriticalSection ;// 再生している３Ｄサウンドリストアクセス時用クリティカルセクション

	int							PlayWavSoundHandle ;			// PlayWav関数で鳴らされているWAVEデータのハンドル

	int							Create3DSoundFlag ;				// 3Dサウンドを作成するかどうかのフラグ( TRUE:３Ｄサウンドを作成する  FALSE:３Ｄサウンドを作成しない )
	int							OldVolumeTypeFlag ;				// Ver3.10c以前の音量計算式を使用するかどうかのフラグ( TRUE:古い計算式を使用する  FALSE:新しい計算式を使用する )
	int							SoundMode ;						// 再生形式

	int							MaxVolume ;						// 最大音量

	int							EnableSoundCaptureFlag ;		// サウンドキャプチャを前提とした動作をする
#ifndef DX_NON_SAVEFUNCTION
	int							SoundCaptureFlag ;				// サウンドキャプチャを実行している最中かどうかのフラグ(TRUE:最中 FASLE:違う)
	int							SoundCaptureSample ;			// キャプチャしたサンプルの数(44.1KHz換算)
	DWORD_PTR					SoundCaptureFileHandle ;		// キャプチャしたサウンドを保存しているファイル
#endif // DX_NON_SAVEFUNCTION

	int							CreateSoundDataType ;					// 作成するサウンドデータのデータタイプ
	int							CreateSoundPitchRateEnable ;			// 作成するサウンドデータのピッチレートが有効かどうか
	float						CreateSoundPitchRate ;					// 作成するサウンドデータのピッチレート
	float						CreateSoundPitchRate_Cents ;			// 作成するサウンドデータのピッチレート( セント単位 )
	int							CreateSoundTimeStretchRateEnable ;		// 作成するサウンドデータのタイムストレッチレートが有効かどうか
	float						CreateSoundTimeStretchRate ;			// 作成するサウンドデータのタイムストレッチレート
	int							CreateSoundLoopStartTimePosition ;		// 作成するサウンドデータのループ範囲の先端( ミリ秒 )
	int							CreateSoundLoopStartSamplePosition ;	// 作成するサウンドデータのループ範囲の先端( サンプル )
	int							CreateSoundLoopEndTimePosition ;		// 作成するサウンドデータのループ範囲の終端( ミリ秒 )
	int							CreateSoundLoopEndSamplePosition ;		// 作成するサウンドデータのループ範囲の終端( サンプル )
	int							DisableReadSoundFunctionMask ;			// 使用しない読み込み処理のマスク
#ifndef DX_NON_OGGVORBIS
	int							OggVorbisBitDepth ;				// ＯｇｇＶｏｒｂｉｓ使用時のビット深度(1:8bit 2:16bit)
	int							OggVorbisFromTheoraFile ;		// Ogg Theora ファイル中の Vorbis データを参照するかどうかのフラグ( TRUE:Theora ファイル中の Vorbis データを参照する )
#endif

#ifndef DX_NON_BEEP
	int							BeepFrequency ;									// 再生するBEEP音の周波数
	int							BeepPlay ;										// BEEPを再生中かどうか
	int							BeepSoundBufferUseIndex ;						// 使用するBEEP音再生用のサウンドバッファ
	SOUND_BEEP_BUFFERDATA		BeepSoundBuffer[ SOUND_BEEPSOUNDBUFFER_NUM ] ;	// BEEP音用のサウンドバッファ関連情報
#endif

	short						SinTable[ SOUND_SINTABLE_DIV ] ;	// サインテーブル

	SOUNDSYSTEMDATA_PF			PF ;							// 環境依存情報
} ;</pre>
			<p>のように定義されています。</p>
		</section>
		<section>
			<h3>CreateSoundDataType</h3>
			<p>で大事なのは<code>CreateSoundDataType</code>です。これが取りうる値は</p>
			<dl>
				<dt>DX_SOUNDDATATYPE_MEMNOPRESS</dt>
				<dd>圧縮された全データは再生が始まる前にサウンドメモリにすべて展開され、格納される。</dd>
				<dt>DX_SOUNDDATATYPE_MEMPRESS</dt>
				<dd>圧縮された全データはシステムメモリに格納され、再生する部分だけ逐次展開しながらサウンドメモリに格納する(鳴らし終わると展開したデータは破棄されるので何度も展開処理が行われる)</dd>
				<dt>DX_SOUNDDATATYPE_FILE</dt>
				<dd>圧縮されたデータの再生する部分だけファイルから逐次読み込み展開され、サウンドメモリに格納される(鳴らし終わると展開したデータは破棄されるので何度も展開処理が行われる)</dd>
			</dl>
			<p>
				の3つです。まあ<code>DX_SOUNDDATATYPE_MEMNOPRESS_PLUS</code>というのもあるんですが、<br>
				後述する<code>NS_SetCreateSoundDataType</code>関数内に<code>DX_SOUNDDATATYPE_MEMNOPRESS</code>に強制置換するコードと現在使えないというコメントがありまして・・・
			</p>
			</section>
		</section>
	<section>
		<h2>初期化処理:<code>DxLib_Init()InitializeSoundSystem()</code></h2>
		<p>皆さんDxLibを使うときはこの<code>DxLib_Init</code>関数を呼んでいることと思いますが、まずはここから行きましょう。</p>
		<p>DxLib_Initの定義は<code>./Windows/DxSystemWin.cpp</code>にあります</p>
		<pre class="brush: cpp; first-line: 65;" title="./Windows/DxSystemWin.cpp">// ライブラリ初期化関数
extern int NS_DxLib_Init( void )
{
	// 既に初期化済みの場合は何もせず終了
	if( DxSysData.DxLib_InitializeFlag == TRUE ) return 0 ;

	DXST_ERRORLOGFMT_ADDUTF16LE(( "\x24\xff\x38\xff\xe9\x30\xa4\x30\xd6\x30\xe9\x30\xea\x30\x6e\x30\x1d\x52\x1f\x67\x16\x53\xe6\x51\x06\x74\x8b\x95\xcb\x59\x00"/*@ L"ＤＸライブラリの初期化処理開始" @*/ )) ;
	DXST_ERRORLOG_TABADD ;

	// 初期化中フラグを立てる
	DxSysData.DxLib_RunInitializeFlag = TRUE ;
</pre>
		<p>でこの230行もある関数の途中に</p>
		<pre class="brush: cpp; first-line: 213; highlight: [217];" title="./Windows/DxSystemWin.cpp">	if( DxSysData.NotSoundFlag == FALSE )
	{
#ifndef DX_NON_SOUND
		InitializeSoundConvert() ;									// サウンド変換処理の初期化
		InitializeSoundSystem() ;									// サウンドシステムのの初期化
#endif // DX_NON_SOUND
	}
</pre>
		<p><code>InitializeSoundSystem</code>という関数があると思います。この関数の定義は<code>DxSound.cpp</code>にあります。</p>
		<pre class="brush: cpp; first-line: 157; highlight: [218];" title="DxSound.cpp">// サウンドシステムを初期化する
extern int InitializeSoundSystem( void )
{
	if( SoundSysData.InitializeFlag )
	{
		return -1 ;
	}

	// 出力レートをセット
	if( SoundSysData.OutputSmaplesPerSec == 0 )
	{
		SoundSysData.OutputSmaplesPerSec = 44100 ;
	}

	// ３Ｄサウンドの１メートルを設定
	if( SoundSysData._3DSoundOneMetreEnable == FALSE )
	{
		SoundSysData._3DSoundOneMetre = 1.0f ;
	}

	// サウンドハンドル管理情報初期化
	InitializeHandleManage( DX_HANDLETYPE_SOUND, sizeof( SOUND ), MAX_SOUND_NUM, InitializeSoundHandle, TerminateSoundHandle, L"Sound" ) ;

	// ソフトウエアで扱う波形データハンドル管理情報初期化
	InitializeHandleManage( DX_HANDLETYPE_SOFTSOUND, sizeof( SOFTSOUND ), MAX_SOFTSOUND_NUM, InitializeSoftSoundHandle, TerminateSoftSoundHandle, L"SoftSound" ) ;

	// ＭＩＤＩハンドル管理情報初期化
	InitializeHandleManage( DX_HANDLETYPE_MUSIC, sizeof( MIDIHANDLEDATA ), MAX_MUSIC_NUM, InitializeMidiHandle, TerminateMidiHandle, L"Music" ) ;

	// クリティカルセクションの初期化
	CriticalSection_Initialize( &SoundSysData._3DSoundListCriticalSection ) ;
	CriticalSection_Initialize( &SoundSysData.Play3DSoundListCriticalSection ) ;
	CriticalSection_Initialize( &SoundSysData.StreamSoundListCriticalSection ) ;

	// ハンドルリストを初期化
	InitializeHandleList( &SoundSysData._3DSoundListFirst,				&SoundSysData._3DSoundListLast ) ;
	InitializeHandleList( &SoundSysData.StreamSoundListFirst,			&SoundSysData.StreamSoundListLast ) ;
	InitializeHandleList( &SoundSysData.SoftSoundPlayerListFirst,		&SoundSysData.SoftSoundPlayerListLast ) ;
	InitializeHandleList( &SoundSysData.PlayFinishDeleteSoundListFirst, &SoundSysData.PlayFinishDeleteSoundListLast ) ;
	InitializeHandleList( &SoundSysData.Play3DSoundListFirst,			&SoundSysData.Play3DSoundListLast ) ;

	// サインテーブルの初期化
	{
		int i ;
		float Sin ;
		float Cos ;

		for( i = 0 ; i < SOUND_SINTABLE_DIV ; i ++ )
		{
			_SINCOS( i * DX_PI_F * 2 / SOUND_SINTABLE_DIV, &Sin, &Cos ) ;
			SoundSysData.SinTable[ i ] = ( short )_FTOL( Sin * 16384.0f ) ;
		}
	}

	// 環境依存処理
	if( InitializeSoundSystem_PF_Timing0() < 0 )
	{
		return -1 ;
	}

	// 作成する音のデータタイプをセット
	SoundSysData.CreateSoundDataType = DX_SOUNDDATATYPE_MEMNOPRESS ;

	// 作成する音のピッチレートをセット
	SoundSysData.CreateSoundPitchRateEnable = FALSE ;
	SoundSysData.CreateSoundPitchRate = 1.0f ;

	// 作成する音のタイムストレッチレートをセット
	SoundSysData.CreateSoundTimeStretchRateEnable = FALSE ;
	SoundSysData.CreateSoundTimeStretchRate = 1.0f ;

#ifndef DX_NON_OGGVORBIS
	// ＯｇｇＶｏｒｂｉｓのＰＣＭデコード時の、ビット深度を１６bitにセット
	SoundSysData.OggVorbisBitDepth = 2 ;
#endif // DX_NON_OGGVORBIS

	// ３Ｄサウンド処理用のリスナー情報を初期化
	SoundSysData.ListenerInfo.Position			= VGet( 0.0f, 0.0f, 0.0f ) ;
	SoundSysData.ListenerInfo.FrontDirection	= VGet( 0.0f, 0.0f, 1.0f ) ;
	SoundSysData.ListenerInfo.Velocity			= VGet( 0.0f, 0.0f, 0.0f ) ;
	SoundSysData.ListenerInfo.InnerAngle		= DX_PI_F * 5.0f / 6.0f ;
	SoundSysData.ListenerInfo.OuterAngle		= DX_PI_F * 11.0f / 6.0f ;
	SoundSysData.ListenerInfo.InnerVolume		= 1.0f ;
	SoundSysData.ListenerInfo.OuterVolume		= 0.75f ;
	SoundSysData.ListenerSideDirection			= VGet( 1.0f, 0.0f, 0.0f ) ;

	// 初期化フラグを立てる
	SoundSysData.InitializeFlag = TRUE ;

	NS_InitSoundMem() ;
	NS_InitSoftSound() ;
	NS_InitSoftSoundPlayer() ;

	// 環境依存処理
	if( InitializeSoundSystem_PF_Timing1() < 0 )
	{
		return -1 ;
	}

#ifndef DX_NON_BEEP
	// BEEP音の初期化
	if( BeepSound_Initialize() < 0 )
	{
		return -1 ;
	}
#endif //DX_NON_BEEP

	// 終了
	return 0 ;
}</pre>
		<p>つまりデフォルトでは<code>SoundSysData.CreateSoundDataType</code>は<code>DX_SOUNDDATATYPE_MEMNOPRESS</code>だということがわかりました。</p>
</section>
</body>
</html>